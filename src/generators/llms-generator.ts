// ============================================================
// llms.txt Generator
// Feature 2b: Generate the emerging llms.txt standard (2026)
// Spec: https://llmstxt.org
// ============================================================

import type { LLMSConfig, LLMSPage } from '../types'

/**
 * LLMSTextGenerator
 *
 * Generates an llms.txt file — a plain-text index of your site
 * designed specifically for Large Language Models to understand
 * your content without crawling every page.
 *
 * @example
 * ```ts
 * import { LLMSTextGenerator } from 'ai-visibility'
 * import fs from 'fs'
 *
 * const gen = new LLMSTextGenerator({
 *   siteName: 'MyApp',
 *   description: 'The best Node.js framework for AI',
 *   baseUrl: 'https://myapp.com',
 *   pages: [
 *     { url: '/product', title: 'Product', priority: 'high' },
 *     { url: '/pricing', title: 'Pricing', summary: '$29/month for Pro plan' },
 *     { url: '/docs', title: 'Documentation' },
 *   ],
 * })
 *
 * const content = await gen.generate()
 * fs.writeFileSync('./public/llms.txt', content)
 * ```
 */
export class LLMSTextGenerator {
    private config: LLMSConfig

    constructor(config: LLMSConfig) {
        this.config = config
    }

    /**
     * Generate the llms.txt content.
     * If autoSummarize is true and a page has no summary, it will attempt
     * to fetch the page and extract the first meaningful paragraph.
     */
    async generate(): Promise<string> {
        const { siteName, description, baseUrl, pages, contact } = this.config
        const lines: string[] = []

        // Header
        lines.push(`# ${siteName}`)
        lines.push('')
        lines.push(`> ${description}`)
        lines.push('')

        // Contact / author block
        if (contact) {
            lines.push('## About')
            lines.push('')
            if (contact.email) lines.push(`- Email: ${contact.email}`)
            if (contact.twitter) lines.push(`- Twitter: ${contact.twitter}`)
            if (contact.github) lines.push(`- GitHub: ${contact.github}`)
            lines.push('')
        }

        // Sort pages: high priority first
        const sorted = [...pages].sort((a, b) => {
            const order = { high: 0, medium: 1, low: 2, undefined: 1 }
            return (order[a.priority ?? 'medium'] ?? 1) - (order[b.priority ?? 'medium'] ?? 1)
        })

        // High priority pages
        const highPriority = sorted.filter((p) => p.priority === 'high')
        const rest = sorted.filter((p) => p.priority !== 'high')

        if (highPriority.length > 0) {
            lines.push('## Key Resources')
            lines.push('')
            for (const page of highPriority) {
                await this.appendPage(lines, page, baseUrl)
            }
        }

        if (rest.length > 0) {
            lines.push('## All Pages')
            lines.push('')
            for (const page of rest) {
                await this.appendPage(lines, page, baseUrl)
            }
        }

        // Footer
        lines.push('---')
        lines.push(`Generated by ai-visibility — https://github.com/yourusername/ai-visibility`)

        return lines.join('\n')
    }

    private async appendPage(
        lines: string[],
        page: LLMSPage,
        baseUrl?: string
    ): Promise<void> {
        const fullUrl = this.resolveUrl(page.url, baseUrl)

        lines.push(`### ${page.title}`)
        lines.push(`URL: ${fullUrl}`)

        let summary = page.summary

        if (!summary && this.config.autoSummarize) {
            summary = await this.fetchSummary(fullUrl)
        }

        if (summary) {
            lines.push('')
            lines.push(summary)
        }

        lines.push('')
    }

    private resolveUrl(url: string, baseUrl?: string): string {
        if (url.startsWith('http://') || url.startsWith('https://')) {
            return url
        }
        if (baseUrl) {
            return `${baseUrl.replace(/\/$/, '')}${url.startsWith('/') ? url : `/${url}`}`
        }
        return url
    }

    /**
     * Attempt to fetch a live URL and extract its first meaningful paragraph.
     * Falls back gracefully if fetch fails.
     */
    private async fetchSummary(url: string): Promise<string> {
        try {
            const response = await fetch(url, {
                headers: { 'User-Agent': 'ai-visibility/0.1.0 (llms.txt generator)' },
                signal: AbortSignal.timeout(5000),
            })

            if (!response.ok) return ''

            const html = await response.text()

            // Simple extraction: find first <p> in main content areas
            const match = html.match(
                /<(?:article|main|\.content)[^>]*>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i
            ) ?? html.match(/<p[^>]*>([\s\S]*?)<\/p>/i)

            if (match) {
                // Strip HTML tags and trim
                const text = match[1]
                    .replace(/<[^>]+>/g, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                return text.slice(0, 300) + (text.length > 300 ? '...' : '')
            }

            return ''
        } catch {
            return ''
        }
    }

    /**
     * Generate a minimal llms.txt with just URLs and titles.
     * Useful for large sites where you don't want summaries.
     */
    static minimal(config: LLMSConfig): string {
        const lines: string[] = []
        lines.push(`# ${config.siteName}`)
        lines.push('')
        lines.push(`> ${config.description}`)
        lines.push('')
        lines.push('## Pages')
        lines.push('')

        for (const page of config.pages) {
            const base = config.baseUrl?.replace(/\/$/, '') ?? ''
            const url = page.url.startsWith('http') ? page.url : `${base}${page.url}`
            lines.push(`- [${page.title}](${url})`)
        }

        return lines.join('\n')
    }
}
